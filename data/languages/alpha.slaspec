# sleigh specification file for DEC Alpha
#
# Copyright (c) 2024 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#


#--------------------------------------------------------------------------
# Spaces

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=8  wordsize=1 default;
define space register type=register_space size=8;


#--------------------------------------------------------------------------
# Registers

# integer registers
define register offset=0x00 size=8 [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                                     R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

# floating point registers
define register offset=0x100 size=8 [ F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10 F11 F12 F13 F14 F15
                                      F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31];

# program counter
define register offset=0x200 size=8 [ PC ];

# variables
define register offset=0x208 size=8 [ loc ];

#--------------------------------------------------------------------------
# Tokens

# PALcode format
#define token palcode (32)
#        opcode    = (26, 31)
#        number    = ( 0, 25) dec # PALcode function
#;

# Branch format
#define token branch (32)
#        opcode    = (26, 31)
#        ra        = (21, 25) # Register a
#        bdisp     = ( 0, 20) # branch displacement
#;

# Memory format
define token memory (32)
        opcode    = (26, 31)
        ra        = (21, 25) # Register a
        bdisp     = ( 0, 20) # branch displacement
        rb        = (16, 20) # Register b
        function  = ( 0, 15) # memory format with function code
        mdisp     = ( 0, 15) dec # memory displacement
        jop       = (14, 15) # jump opcode
        jdisp     = ( 0, 13) # jump displacement
        sbz       = (13, 15) # should be zero
        lit       = (13, 20) # literal
        bit12     = (12, 12) # bit 12: 0->SBZ, 1->LIT
;

# Operate format
#define token operate (32)
#        function  = ( 5, 15) # memory instruction with function code
#        rc        = ( 0,  4) # Register c
#;

#--------------------------------------------------------------------------
# Variables

attach variables [ ra ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
attach variables [ rb ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
#attach variables [ rc ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
#                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

#--------------------------------------------------------------------------
# Tables

# LDAx

#  LDA Ra, disp(Rb)
disp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:2); export ptr; }
#  LDAH Ra, 32767(Rb)
hdisp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:2)*65536; export ptr; }

# PC relative displacement
disp_al: loc is bdisp [ loc = inst_start + 4; ] { ptr:8 = loc:8 + sext(bdisp:3)*4; export *[ram]:8 ptr; }

# jump hint
hint: jdisp is jdisp { ptr:8 = sext(jdisp:2)*4; export *[ram]:8 ptr; }

#--------------------------------------------------------------------------
# Mnemonics

#=========================================================================
# Memory Integer Load/Store Instructions
#=========================================================================

# load address
:LDA  ra, disp_regb is opcode=0x08 & ra & disp_regb { ra = disp_regb; }
# load address high
:LDAH ra, hdisp_regb is opcode=0x09 & ra & hdisp_regb { ra = hdisp_regb; }

# load zero-extended byte from memory
:LDBU ra, disp_regb is opcode=0x0a & ra & disp_regb { ra = zext(*:1 disp_regb); }
:LDL  ra, disp_regb is opcode=0x28 & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ  ra, disp_regb is opcode=0x29 & ra & disp_regb { ra = *disp_regb; }
:LDWU ra, disp_regb is opcode=0x0c & ra & disp_regb { ra = zext(*:2 disp_regb); }

# load unaligned memory
:LDQ_U ra, disp_regb is opcode=0x0b & ra & disp_regb { ptr = disp_regb & ~7; ra = *ptr; }

# load memory locked
:LDL_L  ra, disp_regb is opcode=0x2a & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ_L  ra, disp_regb is opcode=0x2b & ra & disp_regb { ra = disp_regb; }

# store to memory conditional
:STL_C  ra, disp_regb is opcode=0x2e & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ_C  ra, disp_regb is opcode=0x2f & ra & disp_regb { *disp_regb = ra; }

# store to memory
:STB  ra, disp_regb is opcode=0x0e & ra & disp_regb { *:1 disp_regb = ra:1; }
:STL  ra, disp_regb is opcode=0x2c & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ  ra, disp_regb is opcode=0x2d & ra & disp_regb { *disp_regb = ra; }
:STW  ra, disp_regb is opcode=0x0d & ra & disp_regb { *:2 disp_regb = ra:2; }

# store to unaligned
:STQ_U  ra, disp_regb is opcode=0x0f & ra & disp_regb { ptr = disp_regb & ~7; *ptr = ra; }

#=========================================================================
# Control Instructions
#=========================================================================

# PC-relative branch
:BR   disp_al is opcode=0x30 & disp_al { goto [disp_al]; }
:BSR  disp_al is opcode=0x34 & disp_al { goto [disp_al]; }

# PC-relative branch conditional
:BEQ  disp_al is opcode=0x39 & disp_al { goto [disp_al]; }
:BGE  disp_al is opcode=0x3e & disp_al { goto [disp_al]; }
:BGT  disp_al is opcode=0x3f & disp_al { goto [disp_al]; }
:BLBC disp_al is opcode=0x38 & disp_al { goto [disp_al]; }
:BLBS disp_al is opcode=0x3c & disp_al { goto [disp_al]; }
:BLE  disp_al is opcode=0x3b & disp_al { goto [disp_al]; }
:BLT  disp_al is opcode=0x3a & disp_al { goto [disp_al]; }
:BNE  disp_al is opcode=0x3d & disp_al { goto [disp_al]; }

# jumps
:JMP ra,(rb),hint is opcode=0x1a & jop = 0 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:JSR ra,(rb),hint is opcode=0x1a & jop = 1 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:RET ra,(rb),hint is opcode=0x1a & jop = 2 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:JSR_COROUTINE ra,(rb),hint is opcode=0x1a & jop = 3 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
