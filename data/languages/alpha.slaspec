# sleigh specification file for DEC Alpha
#
# Copyright (c) 2024 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#


#--------------------------------------------------------------------------
# Spaces

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=8  wordsize=1 default;
define space register type=register_space size=8;


#--------------------------------------------------------------------------
# Registers

# integer registers
define register offset=0x00 size=8 [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                                     R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

# floating point registers
define register offset=0x100 size=8 [ F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10 F11 F12 F13 F14 F15
                                      F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31];

# program counter
define register offset=0x200 size=8 [ PC ];

# variables
define register offset=0x208 size=8 [ loc ];

#--------------------------------------------------------------------------
# Tokens

# Instruction format
define token inst (32)
        opcode = (26, 31)
        ra     = (21, 25) # Register a
        bdisp  = ( 0, 20) # branch displacement
        rb     = (16, 20) # Register b
        mfunc  = ( 0, 15) # memory format with function code
        mdisp  = ( 0, 15) dec # memory displacement
        jop    = (14, 15) # jump opcode
        jdisp  = ( 0, 13) # jump displacement
        sbz    = (13, 15) # should be zero
        lit    = (13, 20) # literal
        is_lit = (12, 12) # bit 12: 0->SBZ, 1->LIT
        ofunc  = ( 5, 11) # operate function
        rc     = ( 0,  4) # Register c
;

#--------------------------------------------------------------------------
# Variables

attach variables [ ra ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
attach variables [ rb ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
attach variables [ rc ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

#--------------------------------------------------------------------------
# Tables

# LDAx

#  LDA Ra, disp(Rb)
disp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:2); export ptr; }
#  LDAH Ra, 32767(Rb)
hdisp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:2)*65536; export ptr; }

# PC relative displacement
disp_al: loc is bdisp [ loc = inst_start + 4; ] { ptr:8 = loc:8 + sext(bdisp:3)*4; export *[ram]:8 ptr; }

# jump hint
hint: jdisp is jdisp { ptr:8 = sext(jdisp:2)*4; export *[ram]:8 ptr; }

# arith operand
op: lit is lit & is_lit = 1 { export *[const]:8 lit; }
op: rb  is rb  & is_lit = 0 { export rb; }

#--------------------------------------------------------------------------
# Mnemonics

#=========================================================================
# Memory Integer Load/Store Instructions
#=========================================================================

# load address
:LDA  ra, disp_regb is opcode=0x08 & ra & disp_regb { ra = disp_regb; }
# load address high
:LDAH ra, hdisp_regb is opcode=0x09 & ra & hdisp_regb { ra = hdisp_regb; }

# load zero-extended byte from memory
:LDBU ra, disp_regb is opcode=0x0a & ra & disp_regb { ra = zext(*:1 disp_regb); }
:LDL  ra, disp_regb is opcode=0x28 & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ  ra, disp_regb is opcode=0x29 & ra & disp_regb { ra = *disp_regb; }
:LDWU ra, disp_regb is opcode=0x0c & ra & disp_regb { ra = zext(*:2 disp_regb); }

# load unaligned memory
:LDQ_U ra, disp_regb is opcode=0x0b & ra & disp_regb { ptr = disp_regb & ~7; ra = *ptr; }

# load memory locked
:LDL_L  ra, disp_regb is opcode=0x2a & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ_L  ra, disp_regb is opcode=0x2b & ra & disp_regb { ra = disp_regb; }

# store to memory conditional
:STL_C  ra, disp_regb is opcode=0x2e & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ_C  ra, disp_regb is opcode=0x2f & ra & disp_regb { *disp_regb = ra; }

# store to memory
:STB  ra, disp_regb is opcode=0x0e & ra & disp_regb { *:1 disp_regb = ra:1; }
:STL  ra, disp_regb is opcode=0x2c & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ  ra, disp_regb is opcode=0x2d & ra & disp_regb { *disp_regb = ra; }
:STW  ra, disp_regb is opcode=0x0d & ra & disp_regb { *:2 disp_regb = ra:2; }

# store to unaligned
:STQ_U  ra, disp_regb is opcode=0x0f & ra & disp_regb { ptr = disp_regb & ~7; *ptr = ra; }

#=========================================================================
# Control Instructions
#=========================================================================

# PC-relative branch
:BR   disp_al is opcode=0x30 & disp_al { goto [disp_al]; }
:BSR  disp_al is opcode=0x34 & disp_al { goto [disp_al]; }

# PC-relative branch conditional
:BEQ  disp_al is opcode=0x39 & disp_al { goto [disp_al]; }
:BGE  disp_al is opcode=0x3e & disp_al { goto [disp_al]; }
:BGT  disp_al is opcode=0x3f & disp_al { goto [disp_al]; }
:BLBC disp_al is opcode=0x38 & disp_al { goto [disp_al]; }
:BLBS disp_al is opcode=0x3c & disp_al { goto [disp_al]; }
:BLE  disp_al is opcode=0x3b & disp_al { goto [disp_al]; }
:BLT  disp_al is opcode=0x3a & disp_al { goto [disp_al]; }
:BNE  disp_al is opcode=0x3d & disp_al { goto [disp_al]; }

# jumps
:JMP ra,(rb),hint is opcode=0x1a & jop = 0 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:JSR ra,(rb),hint is opcode=0x1a & jop = 1 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:RET ra,(rb),hint is opcode=0x1a & jop = 2 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }
:JSR_COROUTINE ra,(rb),hint is opcode=0x1a & jop = 3 & ra & rb & hint { ptr:8 = rb & ~3; goto [ptr]; }

#=========================================================================
# Integer Arithmetic Instructions
#=========================================================================

# add
:ADDL   ra, op, rc is opcode=0x10 & ofunc=0x00 & ra & op & rc { tmp = ra:4 + op:4; rc = sext(tmp); }
:ADDL^"/V"   ra, op, rc is opcode=0x10 & ofunc=0x40 & ra & op & rc { tmp = ra:4 + op:4; rc = sext(tmp); }
:S4ADDL ra, op, rc is opcode=0x10 & ofunc=0x02 & ra & op & rc { tmp = ra:4 << 2; tmp = tmp + op:4; rc = sext(tmp); }
:S8ADDL ra, op, rc is opcode=0x10 & ofunc=0x12 & ra & op & rc { tmp = ra:4 << 3; tmp = tmp + op:4; rc = sext(tmp); }
:ADDQ   ra, op, rc is opcode=0x10 & ofunc=0x20 & ra & op & rc { rc = ra + op; }
:ADDQ^"/V"   ra, op, rc is opcode=0x10 & ofunc=0x60 & ra & op & rc { rc = ra + op; }
:S4ADDQ ra, op, rc is opcode=0x10 & ofunc=0x22 & ra & op & rc { tmp = ra << 2; rc = tmp + op; }
:S8ADDQ ra, op, rc is opcode=0x10 & ofunc=0x32 & ra & op & rc { tmp = ra << 3; rc = tmp + op; }

# compare
:CMPEQ  ra, op, rc is opcode=0x10 & ofunc=0x2d & ra & op & rc { rc = zext(ra == op); }
:CMPLE  ra, op, rc is opcode=0x10 & ofunc=0x6d & ra & op & rc { rc = zext(ra == op) + zext(ra s< op); }
:CMPLT  ra, op, rc is opcode=0x10 & ofunc=0x4d & ra & op & rc { rc = zext(ra s< op); }
:CMPULE ra, op, rc is opcode=0x10 & ofunc=0x3d & ra & op & rc { rc = zext(ra == op) + zext(ra < op); }
:CMPULT ra, op, rc is opcode=0x10 & ofunc=0x1d & ra & op & rc { rc = zext(ra < op); }

# count bits
:CTLZ   rb, rc     is opcode=0x1c & ofunc=0x32 & ra=31 & rb & rc unimpl
:CTPOP  rb, rc     is opcode=0x1c & ofunc=0x30 & ra=31 & rb & rc unimpl
:CTTZ   rb, rc     is opcode=0x1c & ofunc=0x33 & ra=31 & rb & rc unimpl

# multiply
:MULL      ra, op, rc is opcode=0x13 & ofunc=0x00 & ra & op & rc { rc = sext(ra:4 * op:4); }
:MULL^"/V" ra, op, rc is opcode=0x13 & ofunc=0x40 & ra & op & rc { rc = sext(ra:4 * op:4); }
:MULQ      ra, op, rc is opcode=0x13 & ofunc=0x20 & ra & op & rc { rc = ra * op; }
:MULQ^"/V" ra, op, rc is opcode=0x13 & ofunc=0x60 & ra & op & rc { rc = ra * op; }
:UMULH     ra, op, rc is opcode=0x13 & ofunc=0x30 & ra & op & rc { tmp:16 = zext(ra) * zext(op); tmp = (tmp >> 64); rc = tmp:8; }

# subtract
:SUBL   ra, op, rc is opcode=0x10 & ofunc=0x09 & ra & op & rc { tmp = ra:4 - op:4; rc = sext(tmp); }
:SUBL^"/V"   ra, op, rc is opcode=0x10 & ofunc=0x49 & ra & op & rc { tmp = ra:4 - op:4; rc = sext(tmp); }
:S4SUBL ra, op, rc is opcode=0x10 & ofunc=0x0b & ra & op & rc { tmp = ra:4 << 2; tmp = tmp - op:4; rc = sext(tmp); }
:S8SUBL ra, op, rc is opcode=0x10 & ofunc=0x1b & ra & op & rc { tmp = ra:4 << 3; tmp = tmp - op:4; rc = sext(tmp); }
:SUBQ   ra, op, rc is opcode=0x10 & ofunc=0x29 & ra & op & rc { rc = ra - op; }
:SUBQ^"/V"   ra, op, rc is opcode=0x10 & ofunc=0x69 & ra & op & rc { rc = ra - op; }
:S4SUBQ ra, op, rc is opcode=0x10 & ofunc=0x2b & ra & op & rc { tmp = ra << 2; rc = tmp - op; }
:S8SUBQ ra, op, rc is opcode=0x10 & ofunc=0x3b & ra & op & rc { tmp = ra << 3; rc = tmp - op; }
