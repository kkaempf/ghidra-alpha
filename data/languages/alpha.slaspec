# sleigh specification file for DEC Alpha
#
# Copyright (c) 2024 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#


#--------------------------------------------------------------------------
# Spaces

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=8  wordsize=1 default;
define space register type=register_space size=8;


#--------------------------------------------------------------------------
# Registers

# integer registers
define register offset=0x00 size=8 [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                                     R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

# floating point registers
define register offset=0x100 size=8 [ F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10 F11 F12 F13 F14 F15
                                      F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31];

# program counter
define register offset=0x200 size=8 [ PC ];

#--------------------------------------------------------------------------
# Tokens

# PALcode format
#define token palcode (32)
#        opcode    = (26, 31)
#        number    = ( 0, 25) dec # PALcode function
#;

# Branch format
#define token branch (32)
#        opcode    = (26, 31)
#        ra        = (21, 25) # Register a
#        bdisp     = ( 0, 20) # branch displacement
#;

# Memory format
define token memory (32)
        opcode    = (26, 31)
        ra        = (21, 25) # Register a
        rb        = (16, 20) # Register b
        mdisp     = ( 0, 15) dec # memory displacement
;

# Operate format
#define token operate (32)
#        function  = ( 5, 15) # memory instruction with function code
#        rc        = ( 0,  4) # Register c
#;

#--------------------------------------------------------------------------
# Variables

attach variables [ ra ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
attach variables [ rb ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];
#attach variables [ rc ] [ R0  R1  R2  R3  R4  R5  R6  R7  R8  R9  R10 R11 R12 R13 R14 R15
#                          R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 R26 R27 R28 R29 R30 zero];

#--------------------------------------------------------------------------
# Tables

# LDAx

#  LDA Ra, disp(Rb)
disp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:4); export ptr; }
#  LDAH Ra, 32767(Rb)
hdisp_regb: mdisp(rb) is mdisp & rb { ptr:8 = rb + sext(mdisp:4)*65536; export ptr; }

#--------------------------------------------------------------------------
# Mnemonics

#=========================================================================
# Memory Integer Load/Store Instructions
#=========================================================================

# load address
:LDA  ra, disp_regb is opcode=0x08 & ra & disp_regb { ra = disp_regb; }
# load address high
:LDAH ra, hdisp_regb is opcode=0x09 & ra & hdisp_regb { ra = hdisp_regb; }

# load zero-extended byte from memory
:LDBU ra, disp_regb is opcode=0x0a & ra & disp_regb { ra = zext(*:1 disp_regb); }
:LDL  ra, disp_regb is opcode=0x28 & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ  ra, disp_regb is opcode=0x29 & ra & disp_regb { ra = *disp_regb; }
:LDWU ra, disp_regb is opcode=0x0c & ra & disp_regb { ra = zext(*:2 disp_regb); }

# load unaligned memory
:LDQ_U ra, disp_regb is opcode=0x0b & ra & disp_regb { ptr = disp_regb & ~7; ra = *ptr; }

# load memory locked
:LDL_L  ra, disp_regb is opcode=0x2a & ra & disp_regb { ra = sext(*:4 disp_regb); }
:LDQ_L  ra, disp_regb is opcode=0x2b & ra & disp_regb { ra = disp_regb; }

# store to memory conditional
:STL_C  ra, disp_regb is opcode=0x2e & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ_C  ra, disp_regb is opcode=0x2f & ra & disp_regb { *disp_regb = ra; }

# store to memory
:STB  ra, disp_regb is opcode=0x0e & ra & disp_regb { *:1 disp_regb = ra:1; }
:STL  ra, disp_regb is opcode=0x2c & ra & disp_regb { *:4 disp_regb = ra:4; }
:STQ  ra, disp_regb is opcode=0x2d & ra & disp_regb { *disp_regb = ra; }
:STW  ra, disp_regb is opcode=0x0d & ra & disp_regb { *:2 disp_regb = ra:2; }

# store to unaligned
:STQ_U  ra, disp_regb is opcode=0x0f & ra & disp_regb { ptr = disp_regb & ~7; *ptr = ra; }

